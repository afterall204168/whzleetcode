#### week contest 198

##### Q1:

```C++
class Solution {
public:
    int numWaterBottles(int numBottles, int numExchange) {
        int ans=numBottles;
        for(;numBottles>=numExchange;)
        {
            ans+=numBottles/numExchange;
            numBottles=numBottles/numExchange+numBottles%numExchange;
        }
        return ans;
    }
};
```

##### Q2:

```C++
class Solution {
    string t;
    vector<int> ans;
    int h[100005],ne[200005],p[200005],m,s[100005][26],f[100005];
    void dfs(int x)
    {
        fill(s[x],s[x]+26,0);
        s[x][t[x]-'a']=1;
        int i,j;
        for(i=h[x];i;i=ne[i])if(p[i]!=f[x])
        {
            f[p[i]]=x;
            dfs(p[i]);
            for(j=0;j<26;j++)s[x][j]+=s[p[i]][j];
        }
        ans[x]=s[x][t[x]-'a'];
    }
public:
    vector<int> countSubTrees(int n, vector<vector<int>>& edges, string labels) {
        ans.resize(n);
        t=labels;
        fill(h,h+n,0);
        m=0;
        for(auto e:edges)
        {
            p[++m]=e[1];
            ne[m]=h[e[0]];
            h[e[0]]=m;
            p[++m]=e[0];
            ne[m]=h[e[1]];
            h[e[1]]=m;
        }
        dfs(0);
        return ans;
    }
};
```

##### Q3:

```C++
class Solution {
    vector<string> ans;
    string t;
    int f[100005],g[100005],h[100005],a[26],b[26],l[100005];
public:
    vector<string> maxNumOfSubstrings(string s) {
        int n=s.size(),i,j,k;
        memset(a,-1,sizeof(a));
        memset(b,-1,sizeof(b));
        for(i=0;i<n;i++)b[s[i]-'a']=i;
        for(i=n-1;~i;i--)a[s[i]-'a']=i;
        fill(l,l+n+1,-1);
        for(i=0;i<26;i++)if(~a[i])
        {
            l[b[i]+1]=a[i];
            for(j=b[i],k=0;j>=l[b[i]+1];j--)if(!(k>>s[j]-'a'&1))if(b[s[j]-'a']==j)
            {
                k|=1<<s[j]-'a';
                l[b[i]+1]=min(l[b[i]+1],a[s[j]-'a']);
            }
            else break;
            if(j>=l[b[i]+1])l[b[i]+1]=-1;
        }
        for(i=1;i<=n;i++)
        {
            f[i]=f[i-1];
            g[i]=g[i-1];
            h[i]=i;
            if(~l[i]&&(f[l[i]]+1>f[i]||f[l[i]]+1==f[i]&&g[l[i]]+i-l[i]<g[i]))
            {
                f[i]=f[l[i]]+1;
                g[i]=g[l[i]]+i-l[i];
                h[i]=l[i];
            }
        }
        ans.clear();
        for(i=n;i;)if(h[i]==i)i--;
        else
        {
            t="";
            for(j=l[i];j<i;j++)t+=s[j];
            ans.push_back(t);
            i=l[i];
        }
        return ans;
    }
};
```

##### Q4:

```C++
class Solution {
    int f[100005][20];
public:
    int closestToTarget(vector<int>& arr, int target) {
        int n=arr.size(),i,j,k,l,ans=1000000000+target;
        memset(f,0,sizeof(f));
        for(i=0;i<n;i++)f[i][0]=arr[i];
        for(i=1;1<<i<=n;i++)for(j=0;j+(1<<i)<=n;j++)f[j][i]=f[j][i-1]&f[j+(1<<i-1)][i-1];
        for(i=0;i<n;i++)
        {
            for(j=19,k=i-1,l=1048575;~j;j--)if(k+(1<<j)<n&&(l&f[k+1][j])>=target)
            {
                l&=f[k+1][j];
                k+=1<<j;
            }
            if(k>=i)ans=min(ans,l-target);
            if(k+1<n)
            {
                l&=arr[k+1];
                ans=min(ans,target-l);
            }
        }
        return ans;
    }
};
```

